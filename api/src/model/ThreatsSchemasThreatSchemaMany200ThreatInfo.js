/*
 * S1 MGMT API
 * SentinelOne Management Console API specification.
 *
 * OpenAPI spec version: 2.1
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 *
 * Swagger Codegen version: 2.4.39
 *
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/ThreatsSchemasThreatSchemaMany200ThreatInfoMacroModules'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('./ThreatsSchemasThreatSchemaMany200ThreatInfoMacroModules'));
  } else {
    // Browser globals (root is window)
    if (!root.S1MgmtApi) {
      root.S1MgmtApi = {};
    }
    root.S1MgmtApi.ThreatsSchemasThreatSchemaMany200ThreatInfo = factory(root.S1MgmtApi.ApiClient, root.S1MgmtApi.ThreatsSchemasThreatSchemaMany200ThreatInfoMacroModules);
  }
}(this, function(ApiClient, ThreatsSchemasThreatSchemaMany200ThreatInfoMacroModules) {
  'use strict';

  /**
   * The ThreatsSchemasThreatSchemaMany200ThreatInfo model module.
   * @module model/ThreatsSchemasThreatSchemaMany200ThreatInfo
   * @version 2.1
   */

  /**
   * Constructs a new <code>ThreatsSchemasThreatSchemaMany200ThreatInfo</code>.
   * Threat information
   * @alias module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo
   * @class
   * @param sha1 {String} SHA1 hash of file content
   */
  var exports = function(sha1) {
    this.sha1 = sha1;
  };

  /**
   * Constructs a <code>ThreatsSchemasThreatSchemaMany200ThreatInfo</code> from a plain JavaScript object, optionally creating a new instance.
   * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
   * @param {Object} data The plain JavaScript object bearing properties of interest.
   * @param {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo} obj Optional instance to populate.
   * @return {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo} The populated <code>ThreatsSchemasThreatSchemaMany200ThreatInfo</code> instance.
   */
  exports.constructFromObject = function(data, obj) {
    if (data) {
      obj = obj || new exports();
      if (data.hasOwnProperty('mitigationStatus'))
        obj.mitigationStatus = ApiClient.convertToType(data['mitigationStatus'], 'String');
      if (data.hasOwnProperty('fileExtensionType'))
        obj.fileExtensionType = ApiClient.convertToType(data['fileExtensionType'], 'String');
      if (data.hasOwnProperty('confidenceLevel'))
        obj.confidenceLevel = ApiClient.convertToType(data['confidenceLevel'], 'String');
      if (data.hasOwnProperty('publisherName'))
        obj.publisherName = ApiClient.convertToType(data['publisherName'], 'String');
      if (data.hasOwnProperty('browserType'))
        obj.browserType = ApiClient.convertToType(data['browserType'], 'String');
      if (data.hasOwnProperty('processUser'))
        obj.processUser = ApiClient.convertToType(data['processUser'], 'String');
      if (data.hasOwnProperty('filePath'))
        obj.filePath = ApiClient.convertToType(data['filePath'], Object);
      if (data.hasOwnProperty('updatedAt'))
        obj.updatedAt = ApiClient.convertToType(data['updatedAt'], 'Date');
      if (data.hasOwnProperty('mitigationStatusDescription'))
        obj.mitigationStatusDescription = ApiClient.convertToType(data['mitigationStatusDescription'], Object);
      if (data.hasOwnProperty('maliciousProcessArguments'))
        obj.maliciousProcessArguments = ApiClient.convertToType(data['maliciousProcessArguments'], 'String');
      if (data.hasOwnProperty('incidentStatusDescription'))
        obj.incidentStatusDescription = ApiClient.convertToType(data['incidentStatusDescription'], Object);
      if (data.hasOwnProperty('rebootRequired'))
        obj.rebootRequired = ApiClient.convertToType(data['rebootRequired'], 'Boolean');
      if (data.hasOwnProperty('collectionId'))
        obj.collectionId = ApiClient.convertToType(data['collectionId'], 'String');
      if (data.hasOwnProperty('automaticallyResolved'))
        obj.automaticallyResolved = ApiClient.convertToType(data['automaticallyResolved'], 'Boolean');
      if (data.hasOwnProperty('macroModules'))
        obj.macroModules = ApiClient.convertToType(data['macroModules'], [ThreatsSchemasThreatSchemaMany200ThreatInfoMacroModules]);
      if (data.hasOwnProperty('pendingActions'))
        obj.pendingActions = ApiClient.convertToType(data['pendingActions'], 'Boolean');
      if (data.hasOwnProperty('reachedEventsLimit'))
        obj.reachedEventsLimit = ApiClient.convertToType(data['reachedEventsLimit'], 'Boolean');
      if (data.hasOwnProperty('md5'))
        obj.md5 = ApiClient.convertToType(data['md5'], 'String');
      if (data.hasOwnProperty('classificationSource'))
        obj.classificationSource = ApiClient.convertToType(data['classificationSource'], 'String');
      if (data.hasOwnProperty('fileExtension'))
        obj.fileExtension = ApiClient.convertToType(data['fileExtension'], 'String');
      if (data.hasOwnProperty('fileSize'))
        obj.fileSize = ApiClient.convertToType(data['fileSize'], 'Number');
      if (data.hasOwnProperty('externalTicketId'))
        obj.externalTicketId = ApiClient.convertToType(data['externalTicketId'], 'String');
      if (data.hasOwnProperty('classification'))
        obj.classification = ApiClient.convertToType(data['classification'], 'String');
      if (data.hasOwnProperty('sha1'))
        obj.sha1 = ApiClient.convertToType(data['sha1'], 'String');
      if (data.hasOwnProperty('failedActions'))
        obj.failedActions = ApiClient.convertToType(data['failedActions'], 'Boolean');
      if (data.hasOwnProperty('analystVerdictDescription'))
        obj.analystVerdictDescription = ApiClient.convertToType(data['analystVerdictDescription'], Object);
      if (data.hasOwnProperty('sha256'))
        obj.sha256 = ApiClient.convertToType(data['sha256'], 'String');
      if (data.hasOwnProperty('originatorProcess'))
        obj.originatorProcess = ApiClient.convertToType(data['originatorProcess'], 'String');
      if (data.hasOwnProperty('fileVerificationType'))
        obj.fileVerificationType = ApiClient.convertToType(data['fileVerificationType'], 'String');
      if (data.hasOwnProperty('isValidCertificate'))
        obj.isValidCertificate = ApiClient.convertToType(data['isValidCertificate'], 'Boolean');
      if (data.hasOwnProperty('isFileless'))
        obj.isFileless = ApiClient.convertToType(data['isFileless'], Object);
      if (data.hasOwnProperty('engines'))
        obj.engines = ApiClient.convertToType(data['engines'], Object);
      if (data.hasOwnProperty('analystVerdict'))
        obj.analystVerdict = ApiClient.convertToType(data['analystVerdict'], 'String');
      if (data.hasOwnProperty('mitigatedPreemptively'))
        obj.mitigatedPreemptively = ApiClient.convertToType(data['mitigatedPreemptively'], 'Boolean');
      if (data.hasOwnProperty('certificateId'))
        obj.certificateId = ApiClient.convertToType(data['certificateId'], 'String');
      if (data.hasOwnProperty('initiatingUsername'))
        obj.initiatingUsername = ApiClient.convertToType(data['initiatingUsername'], 'String');
      if (data.hasOwnProperty('storyline'))
        obj.storyline = ApiClient.convertToType(data['storyline'], 'String');
      if (data.hasOwnProperty('detectionType'))
        obj.detectionType = ApiClient.convertToType(data['detectionType'], 'String');
      if (data.hasOwnProperty('threatName'))
        obj.threatName = ApiClient.convertToType(data['threatName'], 'String');
      if (data.hasOwnProperty('identifiedAt'))
        obj.identifiedAt = ApiClient.convertToType(data['identifiedAt'], 'Date');
      if (data.hasOwnProperty('incidentStatus'))
        obj.incidentStatus = ApiClient.convertToType(data['incidentStatus'], 'String');
      if (data.hasOwnProperty('createdAt'))
        obj.createdAt = ApiClient.convertToType(data['createdAt'], 'Date');
      if (data.hasOwnProperty('initiatedBy'))
        obj.initiatedBy = ApiClient.convertToType(data['initiatedBy'], 'String');
      if (data.hasOwnProperty('initiatedByDescription'))
        obj.initiatedByDescription = ApiClient.convertToType(data['initiatedByDescription'], Object);
      if (data.hasOwnProperty('detectionEngines'))
        obj.detectionEngines = ApiClient.convertToType(data['detectionEngines'], Object);
      if (data.hasOwnProperty('threatId'))
        obj.threatId = ApiClient.convertToType(data['threatId'], 'String');
      if (data.hasOwnProperty('cloudFilesHashVerdict'))
        obj.cloudFilesHashVerdict = ApiClient.convertToType(data['cloudFilesHashVerdict'], 'String');
      if (data.hasOwnProperty('externalTicketExists'))
        obj.externalTicketExists = ApiClient.convertToType(data['externalTicketExists'], Object);
      if (data.hasOwnProperty('initiatingUserId'))
        obj.initiatingUserId = ApiClient.convertToType(data['initiatingUserId'], 'String');
    }
    return obj;
  }

  /**
   * Mitigation status
   * @member {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo.MitigationStatusEnum} mitigationStatus
   */
  exports.prototype.mitigationStatus = undefined;

  /**
   * File extension type
   * @member {String} fileExtensionType
   */
  exports.prototype.fileExtensionType = undefined;

  /**
   * SentinelOne threat confidence level
   * @member {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo.ConfidenceLevelEnum} confidenceLevel
   */
  exports.prototype.confidenceLevel = undefined;

  /**
   * Certificate publisher
   * @member {String} publisherName
   */
  exports.prototype.publisherName = undefined;

  /**
   * Browser type
   * @member {String} browserType
   */
  exports.prototype.browserType = undefined;

  /**
   * Process user
   * @member {String} processUser
   */
  exports.prototype.processUser = undefined;

  /**
   * File path
   * @member {Object} filePath
   */
  exports.prototype.filePath = undefined;

  /**
   * Timestamp of last update
   * @member {Date} updatedAt
   */
  exports.prototype.updatedAt = undefined;

  /**
   * Mitigation status description
   * @member {Object} mitigationStatusDescription
   */
  exports.prototype.mitigationStatusDescription = undefined;

  /**
   * Malicious process arguments
   * @member {String} maliciousProcessArguments
   */
  exports.prototype.maliciousProcessArguments = undefined;

  /**
   * Incident status description
   * @member {Object} incidentStatusDescription
   */
  exports.prototype.incidentStatusDescription = undefined;

  /**
   * A reboot is required on the endpoint for at least one action on the threat
   * @member {Boolean} rebootRequired
   */
  exports.prototype.rebootRequired = undefined;

  /**
   * Collection id
   * @member {String} collectionId
   */
  exports.prototype.collectionId = undefined;

  /**
   * Automatically resolved
   * @member {Boolean} automaticallyResolved
   */
  exports.prototype.automaticallyResolved = undefined;

  /**
   * List of macro modules
   * @member {Array.<module:model/ThreatsSchemasThreatSchemaMany200ThreatInfoMacroModules>} macroModules
   */
  exports.prototype.macroModules = undefined;

  /**
   * At least one action is pending on the threat
   * @member {Boolean} pendingActions
   */
  exports.prototype.pendingActions = undefined;

  /**
   * Has number of OS events for this threat reached the limit, resulting in a partial attack storyline
   * @member {Boolean} reachedEventsLimit
   */
  exports.prototype.reachedEventsLimit = undefined;

  /**
   * Md5
   * @member {String} md5
   */
  exports.prototype.md5 = undefined;

  /**
   * Source of the threat Classification
   * @member {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo.ClassificationSourceEnum} classificationSource
   */
  exports.prototype.classificationSource = undefined;

  /**
   * File extension
   * @member {String} fileExtension
   */
  exports.prototype.fileExtension = undefined;

  /**
   * File size
   * @member {Number} fileSize
   */
  exports.prototype.fileSize = undefined;

  /**
   * External ticket id
   * @member {String} externalTicketId
   */
  exports.prototype.externalTicketId = undefined;

  /**
   * Classification of the threat
   * @member {String} classification
   */
  exports.prototype.classification = undefined;

  /**
   * SHA1 hash of file content
   * @member {String} sha1
   */
  exports.prototype.sha1 = undefined;

  /**
   * At least one action failed on the threat
   * @member {Boolean} failedActions
   */
  exports.prototype.failedActions = undefined;

  /**
   * Analyst verdict description
   * @member {Object} analystVerdictDescription
   */
  exports.prototype.analystVerdictDescription = undefined;

  /**
   * SHA256 hash of file content
   * @member {String} sha256
   */
  exports.prototype.sha256 = undefined;

  /**
   * Originator process
   * @member {String} originatorProcess
   */
  exports.prototype.originatorProcess = undefined;

  /**
   * File verification type
   * @member {String} fileVerificationType
   */
  exports.prototype.fileVerificationType = undefined;

  /**
   * True if the certificate is valid
   * @member {Boolean} isValidCertificate
   */
  exports.prototype.isValidCertificate = undefined;

  /**
   * Is fileless
   * @member {Object} isFileless
   */
  exports.prototype.isFileless = undefined;

  /**
   * [Deprecated] List of engines that detected the threat 
   * @member {Object} engines
   */
  exports.prototype.engines = undefined;

  /**
   * Analyst verdict
   * @member {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo.AnalystVerdictEnum} analystVerdict
   */
  exports.prototype.analystVerdict = undefined;

  /**
   * True is the threat was blocked before execution
   * @member {Boolean} mitigatedPreemptively
   */
  exports.prototype.mitigatedPreemptively = undefined;

  /**
   * File Certificate ID
   * @member {String} certificateId
   */
  exports.prototype.certificateId = undefined;

  /**
   * Initiating username
   * @member {String} initiatingUsername
   */
  exports.prototype.initiatingUsername = undefined;

  /**
   * Storyline identifier from agent
   * @member {String} storyline
   */
  exports.prototype.storyline = undefined;

  /**
   * Detection type
   * @member {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo.DetectionTypeEnum} detectionType
   */
  exports.prototype.detectionType = undefined;

  /**
   * Threat name
   * @member {String} threatName
   */
  exports.prototype.threatName = undefined;

  /**
   * Identified at
   * @member {Date} identifiedAt
   */
  exports.prototype.identifiedAt = undefined;

  /**
   * Incident status
   * @member {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo.IncidentStatusEnum} incidentStatus
   */
  exports.prototype.incidentStatus = undefined;

  /**
   * Timestamp of date creation in the Management Console.
   * @member {Date} createdAt
   */
  exports.prototype.createdAt = undefined;

  /**
   * Source of threat
   * @member {module:model/ThreatsSchemasThreatSchemaMany200ThreatInfo.InitiatedByEnum} initiatedBy
   */
  exports.prototype.initiatedBy = undefined;

  /**
   * Initiated by description
   * @member {Object} initiatedByDescription
   */
  exports.prototype.initiatedByDescription = undefined;

  /**
   * List of engines that detected the threat
   * @member {Object} detectionEngines
   */
  exports.prototype.detectionEngines = undefined;

  /**
   * Threat id
   * @member {String} threatId
   */
  exports.prototype.threatId = undefined;

  /**
   * Cloud files hash verdict
   * @member {String} cloudFilesHashVerdict
   */
  exports.prototype.cloudFilesHashVerdict = undefined;

  /**
   * External ticket exists
   * @member {Object} externalTicketExists
   */
  exports.prototype.externalTicketExists = undefined;

  /**
   * Initiating user id
   * @member {String} initiatingUserId
   */
  exports.prototype.initiatingUserId = undefined;



  /**
   * Allowed values for the <code>mitigationStatus</code> property.
   * @enum {String}
   * @readonly
   */
  exports.MitigationStatusEnum = {
    /**
     * value: "not_mitigated"
     * @const
     */
    notMitigated: "not_mitigated",

    /**
     * value: "mitigated"
     * @const
     */
    mitigated: "mitigated",

    /**
     * value: "marked_as_benign"
     * @const
     */
    markedAsBenign: "marked_as_benign"
  };


  /**
   * Allowed values for the <code>confidenceLevel</code> property.
   * @enum {String}
   * @readonly
   */
  exports.ConfidenceLevelEnum = {
    /**
     * value: "malicious"
     * @const
     */
    malicious: "malicious",

    /**
     * value: "suspicious"
     * @const
     */
    suspicious: "suspicious",

    /**
     * value: "n/a"
     * @const
     */
    na: "n/a"
  };


  /**
   * Allowed values for the <code>classificationSource</code> property.
   * @enum {String}
   * @readonly
   */
  exports.ClassificationSourceEnum = {
    /**
     * value: "Cloud"
     * @const
     */
    cloud: "Cloud",

    /**
     * value: "Behavioral"
     * @const
     */
    behavioral: "Behavioral",

    /**
     * value: "Static"
     * @const
     */
    _static: "Static",

    /**
     * value: "Engine"
     * @const
     */
    engine: "Engine"
  };


  /**
   * Allowed values for the <code>analystVerdict</code> property.
   * @enum {String}
   * @readonly
   */
  exports.AnalystVerdictEnum = {
    /**
     * value: "undefined"
     * @const
     */
    _undefined: "undefined",

    /**
     * value: "true_positive"
     * @const
     */
    truePositive: "true_positive",

    /**
     * value: "false_positive"
     * @const
     */
    falsePositive: "false_positive",

    /**
     * value: "suspicious"
     * @const
     */
    suspicious: "suspicious"
  };


  /**
   * Allowed values for the <code>detectionType</code> property.
   * @enum {String}
   * @readonly
   */
  exports.DetectionTypeEnum = {
    /**
     * value: "static"
     * @const
     */
    _static: "static",

    /**
     * value: "dynamic"
     * @const
     */
    dynamic: "dynamic"
  };


  /**
   * Allowed values for the <code>incidentStatus</code> property.
   * @enum {String}
   * @readonly
   */
  exports.IncidentStatusEnum = {
    /**
     * value: "unresolved"
     * @const
     */
    unresolved: "unresolved",

    /**
     * value: "in_progress"
     * @const
     */
    inProgress: "in_progress",

    /**
     * value: "resolved"
     * @const
     */
    resolved: "resolved"
  };


  /**
   * Allowed values for the <code>initiatedBy</code> property.
   * @enum {String}
   * @readonly
   */
  exports.InitiatedByEnum = {
    /**
     * value: "agent_policy"
     * @const
     */
    agentPolicy: "agent_policy",

    /**
     * value: "full_disk_scan"
     * @const
     */
    fullDiskScan: "full_disk_scan",

    /**
     * value: "sentinelctl"
     * @const
     */
    sentinelctl: "sentinelctl",

    /**
     * value: "dv_command"
     * @const
     */
    dvCommand: "dv_command",

    /**
     * value: "console_api"
     * @const
     */
    consoleApi: "console_api",

    /**
     * value: "on_demand_scan"
     * @const
     */
    onDemandScan: "on_demand_scan",

    /**
     * value: "star_active"
     * @const
     */
    starActive: "star_active",

    /**
     * value: "star_manual"
     * @const
     */
    starManual: "star_manual",

    /**
     * value: "cloud_detection"
     * @const
     */
    cloudDetection: "cloud_detection",

    /**
     * value: "threat_intelligence"
     * @const
     */
    threatIntelligence: "threat_intelligence",

    /**
     * value: "watchtower_cloud_detection"
     * @const
     */
    watchtowerCloudDetection: "watchtower_cloud_detection",

    /**
     * value: "multiple"
     * @const
     */
    multiple: "multiple"
  };

  return exports;

}));
